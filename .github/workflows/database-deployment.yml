name: iods-auto-deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  database-deployment:
    runs-on: windows-latest
    env:
      SQL_SERVER_DATA: ""
      SQL_USER: ""
      SQL_PASSWORD: ""
      SQL_DATABASE_IODS: ""
      PATH_RELEASE_IODS: ""
      SQL_DATABASE_PROFICY: ""
      PATH_RELEASE_PROFICY: ""
      SCHEDULE_TASKS_JSON: ""

    steps:
      - name: ⚙️ Checkout code
        uses: actions/checkout@v3

      - name: 📄 Load configuration from JSON
        shell: pwsh
        id: load_config
        run: |
          # read JSON file
          $config = Get-Content -Raw -Path "config.json" | ConvertFrom-Json
          
          # Check JSON file
          Write-Output "Config Loaded: $($config | ConvertTo-Json -Depth 3)"

          $SQL_SERVER_DATA = $config.SQL_SERVER_DATA
          $SQL_USER = $config.SQL_USER
          $SQL_PASSWORD = $config.SQL_PASSWORD
          $SQL_DATABASE_IODS = $config.SQL_DATABASE_IODS
          $PATH_RELEASE_IODS = $config.PATH_RELEASE_IODS
          $SQL_DATABASE_PROFICY = $config.SQL_DATABASE_PROFICY
          $PATH_RELEASE_PROFICY = $config.PATH_RELEASE_PROFICY

          # Assign JSON values to environment variables
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_SERVER_DATA=$SQL_SERVER_DATA"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_USER=$SQL_USER"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_PASSWORD=$SQL_PASSWORD"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_DATABASE_IODS=$SQL_DATABASE_IODS"
          Add-Content -Path $env:GITHUB_ENV -Value "PATH_RELEASE_IODS=$PATH_RELEASE_IODS"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_DATABASE_PROFICY=$SQL_DATABASE_PROFICY"
          Add-Content -Path $env:GITHUB_ENV -Value "PATH_RELEASE_PROFICY=$PATH_RELEASE_PROFICY"

      - name: 📝 Verify environment variables
        shell: pwsh
        run: |
          Write-Output "SQL_SERVER_DATA: $env:SQL_SERVER_DATA"
          Write-Output "SQL_USER: $env:SQL_USER"
          Write-Output "SQL_PASSWORD: $env:SQL_PASSWORD"
          Write-Output "SQL_DATABASE_IODS: $env:SQL_DATABASE_IODS"
          Write-Output "PATH_RELEASE_IODS: $env:PATH_RELEASE_IODS"  
          Write-Output "SQL_DATABASE_PROFICY: $env:SQL_DATABASE_PROFICY"
          Write-Output "PATH_RELEASE_PROFICY: $env:PATH_RELEASE_PROFICY"     
              
      - name: 🛠️ Install SQL Server tools
        run: choco install sqlcmd

      - name: 🔍 Check Server Connection
        shell: pwsh
        run: |
          try {
            Write-Output "Checking database connection..."
            $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -Q "SELECT 1" 2>&1
            if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
              Write-Error "❌ Database connection failed: $output"
              exit 1
            }
            Write-Output "✅ Database connection successful"
          } catch {
            Write-Error "❌ Failed to check database connection: $($_.Exception.Message)"
            exit 1
          }
        
      - name: 🔌Check Auto_opsDataStore Database Connection
        shell: pwsh
        run: |
            try {
              Write-Output "Checking Auto_opsDataStore database connection..."
              $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q "SELECT 1" 2>&1
              if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                Write-Output "❗Database connection failed: $output"
                exit 1
              }
              Write-Output "✅ Auto_opsDataStore Database connection successful"
            } catch {
              Write-Output "❗Failed to check Auto_opsDataStore database connection: $($_.Exception.Message)"
              exit 1
            }
        
      - name: 🔌Check GBDB Database Connection
        shell: pwsh
        run: |
            try {
              Write-Output "Checking GBDB database connection..."
              $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_PROFICY -Q "SELECT 1" 2>&1
              if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                Write-Output "❗Database connection failed: $output"
                exit 1
              }
              Write-Output "✅ GBDB Database connection successful"
            } catch {
              Write-Output "❗Failed to check GBDB database connection: $($_.Exception.Message)"
              exit 1
            }
      
      - name: 📥 Save ScheduleTaskManager to JSON and Deactivate Tasks
        shell: pwsh
        run: |
              try {
                    Write-Output "Fetching data from ScheduleTaskManager..."
                  
                    # Define the path for the JSON file
                    $jsonFile = Join-Path $PWD "ScheduleTaskManager.json"
                  
                    # Execute the SELECT query and convert the result to JSON
                    $query = "SELECT * FROM ScheduleTaskManager FOR JSON AUTO"
                    $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $query -h -1 -W | Where-Object { $_ -notmatch 'rows affected' }

                    # Check for errors in the SQL query execution
                    if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                        Write-Error "❌ Error fetching data: $output"
                        exit 1
                    }

                    # Convert output to JSON format
                    $jsonContentRaw = $output -join "`n"

                    # Save the output to a JSON file
                    $jsonContentRaw | Out-File -Encoding utf8 $jsonFile
                    Write-Output "✅ Data exported successfully to $jsonFile"

                    # Save the JSON content in a GitHub Actions environment variable
                    "SCHEDULE_TASKS_JSON=$jsonContentRaw" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

                    # Print confirmation message
                    Write-Output "📂 JSON stored in GitHub Actions environment variable: SCHEDULE_TASKS_JSON"
                                
                    # Execute the UPDATE query to set Active column to 0 (deactivate tasks)
                    Write-Output "Deactivating tasks by updating Active column to 0..."
                    $updateQuery = "UPDATE ScheduleTaskManager SET Active = 0"
                    $updateOutput = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $updateQuery
                  
                    # Check for errors in the update execution
                    if ($updateOutput -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                        Write-Error "❌ Error deactivating tasks: $updateOutput"
                        exit 1
                    }             
                    Write-Output "✅ Tasks deactivated successfully"
                } 
                catch {
                    # Handle any unexpected errors
                    Write-Error "❌ Failed to process ScheduleTaskManager: $($_.Exception.Message)"
                    exit 1
                }
    
      - name: 🏃‍♂️‍➡️ Execute SQL scripts in the Auto_opsDataStore database
        shell: pwsh
        run: |     
            $folders = Get-ChildItem -Path $env:PATH_RELEASE_IODS -Recurse -Directory | Sort-Object FullName
            
            foreach ($folder in $folders) {
              if ($folder.Name -notmatch '^\d') {
                Write-Output "Skipping folder (no number in name): $($folder.FullName)"
                continue
              }
              Write-Output "Processing folder: $($folder.FullName)"
              $sqlFiles = Get-ChildItem -Path $folder.FullName -Filter *.sql | Sort-Object Name
            
              foreach ($file in $sqlFiles) {            
                try {
                  Write-Output "Executing $($file.FullName)..."
                  $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -i $file.FullName 2>&1
                  Write-Output "Result of $($file.Name):"
                  if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                    Write-Output "❗Error executing $($file.Name): $output"
                  } 
                  else {
                    Write-Output "✅ Successfully executed $($file.Name)"
                  }
                } catch {
                  Write-Error "❌ Failed to execute $($file.Name): $($_.Exception.Message)"
                }
              }
            }
      
      # - name: 🏃‍♂️‍➡️ Execute SQL scripts in the GBDB database
      #   shell: pwsh
      #   run: |     
      #           $folders = Get-ChildItem -Path $env:PATH_RELEASE_PROFICY -Recurse -Directory | Sort-Object FullName
                
      #           foreach ($folder in $folders) {
      #             if ($folder.Name -notmatch '^\d') {
      #               Write-Output "Skipping folder (no number in name): $($folder.FullName)"
      #               continue
      #             }
      #             Write-Output "Processing folder: $($folder.FullName)"
      #             $sqlFiles = Get-ChildItem -Path $folder.FullName -Filter *.sql | Sort-Object Name
                
      #             foreach ($file in $sqlFiles) {            
      #               try {
      #                 Write-Output "Executing $($file.FullName)..."
      #                 $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_PROFICY -i $file.FullName 2>&1
      #                 Write-Output "Result of $($file.Name):"
      #                 if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
      #                   Write-Output "❗Error executing $($file.Name): $output"
      #                 } 
      #                 else {
      #                   Write-Output "✅ Successfully executed $($file.Name)"
      #                 }
      #               } catch {
      #                 Write-Error "❌ Failed to execute $($file.Name): $($_.Exception.Message)"
      #               }
      #             }
      #           }
  
      - name: 🔄 Update Active Status in ScheduleTaskManager
        shell: pwsh
        run: |
                try {
                    Write-Output "📥 Reading JSON from environment variable..."
        
                    # Get the JSON from the environment variable
                    $jsonContentRaw = $env:SCHEDULE_TASKS_JSON
        
                    # Convert the JSON into a PowerShell object array
                    $tasks = $jsonContentRaw | ConvertFrom-Json
        
                    # Check if there are tasks in the JSON
                    if (-not $tasks) {
                        Write-Output "⚠️ No tasks found in JSON."
                        exit 0
                    }
        
                    # Iterate through each JSON object and execute the UPDATE query
                    foreach ($task in $tasks) {
                        $id = $task.Id
                        $active = [int]$task.Active  # Convert boolean to 0 or 1
        
                        Write-Output "🔄 Updating ScheduleTaskManager: Id=$id, Active=$active"
        
                        $updateQuery = "UPDATE ScheduleTaskManager SET Active = $active WHERE Id = $id"
        
                        # Execute the SQL query
                        $updateOutput = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $updateQuery -h -1 -W
        
                        # Check for errors in the SQL execution
                        if ($updateOutput -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                            Write-Error "❌ Error updating Id=$id: $updateOutput"
                            exit 1
                        }
                    }
        
                    Write-Output "✅ All tasks updated successfully."
        
                } catch {
                    Write-Error "❌ Failed to update ScheduleTaskManager: $($_.Exception.Message)"
                    exit 1
                }
              

  api-deployment:
    runs-on: windows-latest
    needs: database-deployment 
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
    
      - name: Deploy API to IIS
        run: |
          echo "Desplegando API en IIS..."