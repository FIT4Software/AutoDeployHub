name: CI

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  connect-sql-server:
    runs-on: windows-latest
    env:
      SQL_SERVER_DATA: ""
      SQL_USER: ""
      SQL_PASSWORD: ""
      SQL_DATABASE: ""
      PATH_RELEASE_APP: ""

    steps:
      - name: ‚öôÔ∏è Checkout code
        uses: actions/checkout@v2

      - name: üìÑ Load configuration from JSON
        shell: pwsh
        id: load_config
        run: |
          # read JSON file
          $config = Get-Content -Raw -Path "config.json" | ConvertFrom-Json
          
          # Check JSON file
          Write-Output "Config Loaded: $($config | ConvertTo-Json -Depth 3)"

          $SQL_SERVER_DATA = $config.SQL_SERVER_DATA
          $SQL_USER = $config.SQL_USER
          $SQL_PASSWORD = $config.SQL_PASSWORD
          $SQL_DATABASE = $config.SQL_DATABASE
          $PATH_RELEASE_APP = $config.PATH_RELEASE_APP

          # Assign JSON values to environment variables
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_SERVER_DATA=$SQL_SERVER_DATA"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_USER=$SQL_USER"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_PASSWORD=$SQL_PASSWORD"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_DATABASE=$SQL_DATABASE"
          Add-Content -Path $env:GITHUB_ENV -Value "PATH_RELEASE_APP=$PATH_RELEASE_APP"

      - name: üìù Verify environment variables
        shell: pwsh
        run: |
          Write-Output "SQL_SERVER_DATA: $env:SQL_SERVER_DATA"
          Write-Output "SQL_USER: $env:SQL_USER"
          Write-Output "SQL_PASSWORD: $env:SQL_PASSWORD"
          Write-Output "SQL_DATABASE: $env:SQL_DATABASE"
          Write-Output "PATH_RELEASE_APP: $env:PATH_RELEASE_APP"

      - name: üì¶ Unzip the release package
        shell: pwsh
        run: |
              # Obtener ruta del archivo ZIP
              $zipFile = "$env:PATH_RELEASE_APP"
              $parentFolder = Split-Path -Path $zipFile -Parent
              $unzipFolder = Join-Path -Path $parentFolder -ChildPath "extracted"
        
              # Depuraci√≥n: Verificar las rutas antes de continuar
              Write-Output "DEBUG - Ruta del archivo ZIP: $zipFile"
              Write-Output "DEBUG - Carpeta Padre: $parentFolder"
              Write-Output "DEBUG - Carpeta de Extracci√≥n: $unzipFolder"
        
              # Verificar si la ruta del archivo ZIP es v√°lida
              if (-Not (Test-Path -Path $zipFile)) {
                  Write-Error "‚ùå ERROR: No se encontr√≥ el archivo ZIP en $zipFile"
                  exit 1
              } else {
                  Write-Output "‚úÖ Archivo ZIP encontrado: $zipFile"
              }
        
              # Verificar si la carpeta padre existe, si no, crearla
              if (-Not (Test-Path -Path $parentFolder)) {
                  Write-Output "‚ùå ERROR: La carpeta padre no existe: $parentFolder"
                  exit 1
              } else {
                  Write-Output "‚úÖ Carpeta padre existe: $parentFolder"
              }
        
              # Verificar si la carpeta 'extracted' ya existe
              if (Test-Path -Path $unzipFolder) {
                  Write-Output "üìÇ La carpeta de extracci√≥n ya existe: $unzipFolder"
              } else {
                  Write-Output "üìÇ Creando la carpeta de extracci√≥n: $unzipFolder"
                  New-Item -ItemType Directory -Path $unzipFolder -Force | Out-Null
        
                  # Verificar si la carpeta se cre√≥ correctamente
                  if (-Not (Test-Path -Path $unzipFolder)) {
                      Write-Error "‚ùå ERROR: No se pudo crear la carpeta de extracci√≥n en $unzipFolder"
                      exit 1
                  } else {
                      Write-Output "‚úÖ Carpeta de extracci√≥n creada exitosamente: $unzipFolder"
                  }
              }
        
              # Descomprimir el archivo ZIP
              Write-Output "üì¶ Descomprimiendo el archivo ZIP en: $unzipFolder"
              try {
                  Expand-Archive -Path $zipFile -DestinationPath $unzipFolder -Force
                  Write-Output "‚úÖ Archivo descomprimido exitosamente."
              } catch {
                  Write-Error "‚ùå ERROR: Fall√≥ la extracci√≥n del ZIP: $_"
                  exit 1
              }
        
              # Verificar si los archivos fueron extra√≠dos correctamente
              $extractedFiles = Get-ChildItem -Path $unzipFolder -Recurse
              if ($extractedFiles.Count -eq 0) {
                  Write-Error "‚ùå ERROR: No se encontraron archivos extra√≠dos en $unzipFolder"
                  exit 1
              } else {
                  Write-Output "üìÇ Se extrajeron $($extractedFiles.Count) archivos en $unzipFolder"
              }
        
              
      - name: üõ†Ô∏è Install SQL Server tools
        run: choco install sqlcmd
           
      - name: üèÉ‚Äç‚ôÇÔ∏è‚Äç‚û°Ô∏è Execute SQL Scripts in Order
        shell: pwsh
        run: |     
            $folders = Get-ChildItem -Path $env:PATH_RELEASE_APP\extracted -Recurse -Directory | Sort-Object FullName
            
            foreach ($folder in $folders) {
              if ($folder.Name -notmatch '^\d') {
                Write-Output "Skipping folder (no number in name): $($folder.FullName)"
                continue
              }
              Write-Output "Processing folder: $($folder.FullName)"
              $sqlFiles = Get-ChildItem -Path $folder.FullName -Filter *.sql | Sort-Object Name
            
              foreach ($file in $sqlFiles) {            
                try {
                  Write-Output "Executing $($file.FullName)..."
                  $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE -i $file.FullName 2>&1
                  Write-Output "Result of $($file.Name):"
                  if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                    Write-Output "‚ùóError executing $($file.Name): $output"
                  } 
                  else {
                    Write-Output "‚úÖ Successfully executed $($file.Name)"
                  }
                } catch {
                  Write-Error "‚ùå Failed to execute $($file.Name): $($_.Exception.Message)"
                }
              }
            }
