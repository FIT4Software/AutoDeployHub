name: iods-auto-deploy

on:
  push:
    branches: ["API-1"]
  workflow_dispatch:

jobs:
  database-deployment:
    runs-on: windows-latest
    env:
      SQL_SERVER_DATA: ""
      SQL_USER: ""
      SQL_PASSWORD: ""
      SQL_DATABASE_IODS: ""
      PATH_RELEASE_IODS: ""
      SQL_DATABASE_PROFICY: ""
      PATH_RELEASE_PROFICY: ""
      SCHEDULE_TASKS_JSON: ""
      IODS_API: ""

    steps:
      - name: âš™ï¸ Checkout code
        uses: actions/checkout@v3

      - name: ðŸ“„ Load configuration from JSON
        shell: pwsh
        id: load_config
        run: |
          # read JSON file
          $config = Get-Content -Raw -Path "config.json" | ConvertFrom-Json

          # Check JSON file
          Write-Output "Config Loaded: $($config | ConvertTo-Json -Depth 3)"

          $SQL_SERVER_DATA = $config.SQL_SERVER_DATA
          $SQL_USER = $config.SQL_USER
          $SQL_PASSWORD = $config.SQL_PASSWORD
          $SQL_DATABASE_IODS = $config.SQL_DATABASE_IODS
          $PATH_RELEASE_IODS = $config.PATH_RELEASE_IODS
          $SQL_DATABASE_PROFICY = $config.SQL_DATABASE_PROFICY
          $PATH_RELEASE_PROFICY = $config.PATH_RELEASE_PROFICY

          # Assign JSON values to environment variables
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_SERVER_DATA=$SQL_SERVER_DATA"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_USER=$SQL_USER"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_PASSWORD=$SQL_PASSWORD"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_DATABASE_IODS=$SQL_DATABASE_IODS"
          Add-Content -Path $env:GITHUB_ENV -Value "PATH_RELEASE_IODS=$PATH_RELEASE_IODS"
          Add-Content -Path $env:GITHUB_ENV -Value "SQL_DATABASE_PROFICY=$SQL_DATABASE_PROFICY"
          Add-Content -Path $env:GITHUB_ENV -Value "PATH_RELEASE_PROFICY=$PATH_RELEASE_PROFICY"

      - name: ðŸ“ Verify environment variables
        shell: pwsh
        run: |
          Write-Output "SQL_SERVER_DATA: $env:SQL_SERVER_DATA"
          Write-Output "SQL_USER: $env:SQL_USER"
          Write-Output "SQL_PASSWORD: $env:SQL_PASSWORD"
          Write-Output "SQL_DATABASE_IODS: $env:SQL_DATABASE_IODS"
          Write-Output "PATH_RELEASE_IODS: $env:PATH_RELEASE_IODS"  
          Write-Output "SQL_DATABASE_PROFICY: $env:SQL_DATABASE_PROFICY"
          Write-Output "PATH_RELEASE_PROFICY: $env:PATH_RELEASE_PROFICY"

      - name: ðŸ› ï¸ Install SQL Server tools
        run: choco install sqlcmd

      - name: ðŸ” Check Server Connection
        shell: pwsh
        run: |
          try {
            Write-Output "Checking database connection..."
            $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -Q "SELECT 1" 2>&1
            if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
              Write-Error "âŒ Database connection failed: $output"
              exit 1
            }
            Write-Output "âœ… Database connection successful"
          } catch {
            Write-Error "âŒ Failed to check database connection: $($_.Exception.Message)"
            exit 1
          }

      - name: ðŸ”ŒCheck Auto_opsDataStore Database Connection
        shell: pwsh
        run: |
          try {
            Write-Output "Checking Auto_opsDataStore database connection..."
            $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q "SELECT 1" 2>&1
            if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
              Write-Output "â—Database connection failed: $output"
              exit 1
            }
            Write-Output "âœ… Auto_opsDataStore Database connection successful"
          } catch {
            Write-Output "â—Failed to check Auto_opsDataStore database connection: $($_.Exception.Message)"
            exit 1
          }

      - name: ðŸ”ŒCheck GBDB Database Connection
        shell: pwsh
        run: |
          try {
            Write-Output "Checking GBDB database connection..."
            $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_PROFICY -Q "SELECT 1" 2>&1
            if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
              Write-Output "â—Database connection failed: $output"
              exit 1
            }
            Write-Output "âœ… GBDB Database connection successful"
          } catch {
            Write-Output "â—Failed to check GBDB database connection: $($_.Exception.Message)"
            exit 1
          }

      - name: ðŸ“¥ Save ScheduleTaskManager to JSON and Deactivate Tasks
        shell: pwsh
        run: |
          try {
                Write-Output "Fetching data from ScheduleTaskManager..."
              
                # Define the path for the JSON file
                $jsonFile = Join-Path $PWD "ScheduleTaskManager.json"
              
                # Execute the SELECT query and convert the result to JSON
                $query = "SELECT * FROM ScheduleTaskManager FOR JSON AUTO"
                $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $query -h -1 -W | Where-Object { $_ -notmatch 'rows affected' }

                # Check for errors in the SQL query execution
                if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                    Write-Error "âŒ Error fetching data: $output"
                    exit 1
                }

                # Convert output to JSON format
                $jsonContentRaw = $output -join "`n"

                # Save the output to a JSON file
                $jsonContentRaw | Out-File -Encoding utf8 $jsonFile
                Write-Output "âœ… Data exported successfully to $jsonFile"

                # Save the JSON content in a GitHub Actions environment variable
                "SCHEDULE_TASKS_JSON=$jsonContentRaw" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

                # Print confirmation message
                Write-Output "ðŸ“‚ JSON stored in GitHub Actions environment variable: SCHEDULE_TASKS_JSON"
                            
                # Execute the UPDATE query to set Active column to 0 (deactivate tasks)
                Write-Output "Deactivating tasks by updating Active column to 0..."
                $updateQuery = "UPDATE ScheduleTaskManager SET Active = 0"
                $updateOutput = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $updateQuery
              
                # Check for errors in the update execution
                if ($updateOutput -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                    Write-Error "âŒ Error deactivating tasks: $updateOutput"
                    exit 1
                }             
                Write-Output "âœ… Tasks deactivated successfully"
            } 
            catch {
                # Handle any unexpected errors
                Write-Error "âŒ Failed to process ScheduleTaskManager: $($_.Exception.Message)"
                exit 1
            }

      - name: ðŸƒâ€â™‚ï¸â€âž¡ï¸ Execute SQL scripts in the Auto_opsDataStore database
        shell: pwsh
        run: |
          $folders = Get-ChildItem -Path $env:PATH_RELEASE_IODS -Recurse -Directory | Sort-Object FullName

          foreach ($folder in $folders) {
            if ($folder.Name -notmatch '^\d') {
              Write-Output "Skipping folder (no number in name): $($folder.FullName)"
              continue
            }
            Write-Output "Processing folder: $($folder.FullName)"
            $sqlFiles = Get-ChildItem -Path $folder.FullName -Filter *.sql | Sort-Object Name

            foreach ($file in $sqlFiles) {            
              try {
                Write-Output "Executing $($file.FullName)..."
                $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -i $file.FullName 2>&1
                Write-Output "Result of $($file.Name):"
                if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                  Write-Output "â—Error executing $($file.Name): $output"
                } 
                else {
                  Write-Output "âœ… Successfully executed $($file.Name)"
                }
              } catch {
                Write-Error "âŒ Failed to execute $($file.Name): $($_.Exception.Message)"
              }
            }
          }

      - name: ðŸƒâ€â™‚ï¸â€âž¡ï¸ Execute SQL scripts in the GBDB database
        shell: pwsh
        run: |
          $folders = Get-ChildItem -Path $env:PATH_RELEASE_PROFICY -Recurse -Directory | Sort-Object FullName

          foreach ($folder in $folders) {
            if ($folder.Name -notmatch '^\d') {
              Write-Output "Skipping folder (no number in name): $($folder.FullName)"
              continue
            }
            Write-Output "Processing folder: $($folder.FullName)"
            $sqlFiles = Get-ChildItem -Path $folder.FullName -Filter *.sql | Sort-Object Name

            foreach ($file in $sqlFiles) {            
              try {
                Write-Output "Executing $($file.FullName)..."
                $output = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_PROFICY -i $file.FullName 2>&1
                Write-Output "Result of $($file.Name):"
                if ($output -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                  Write-Output "â—Error executing $($file.Name): $output"
                } 
                else {
                  Write-Output "âœ… Successfully executed $($file.Name)"
                }
              } catch {
                Write-Error "âŒ Failed to execute $($file.Name): $($_.Exception.Message)"
              }
            }
          }

      - name: ðŸ”„ Update Active Status in ScheduleTaskManager
        if: false
        shell: pwsh
        run: |
          try {
              Write-Output "ðŸ“¥ Reading JSON from environment variable..."

              Write-Output "Raw JSON content: $env:SCHEDULE_TASKS_JSON"

              # Get the JSON from the environment variable
              $jsonContentRaw = $env:SCHEDULE_TASKS_JSON
              Write-Output "Raw JSON length: $($jsonContentRaw.Length)"

              # Convert the JSON into a PowerShell object array
              $tasks = $jsonContentRaw | ConvertFrom-Json

              # Check if there are tasks in the JSON
              if (-not $tasks) {
                  Write-Output "âš ï¸ No tasks found in JSON."
                  exit 0
              }

              # Iterate through each JSON object and execute the UPDATE query
              foreach ($task in $tasks) {
                  $id = $task.Id
                  $active = [int]$task.Active  # Convert boolean to 0 or 1

                  Write-Output "ðŸ”„ Updating ScheduleTaskManager: Id=$id, Active=$active"

                  $updateQuery = "UPDATE ScheduleTaskManager SET Active = $active WHERE Id = $id"

                  # Execute the SQL query
                  $updateOutput = sqlcmd -S $env:SQL_SERVER_DATA -U $env:SQL_USER -P $env:SQL_PASSWORD -d $env:SQL_DATABASE_IODS -Q $updateQuery -h -1 -W

                  # Check for errors in the SQL execution
                  if ($updateOutput -match 'Msg \d+, Level \d+, State \d+, Server .+, Line \d+') {
                      Write-Error "âŒ Error updating Id=" + $id + ": " + $updateOutput
                      exit 1
                  }
              }

              Write-Output "âœ… All tasks updated successfully."

          } catch {
              Write-Error "âŒ Failed to update ScheduleTaskManager: $($_.Exception.Message)"
              exit 1
          }

  api-deployment:
    runs-on: windows-latest
    needs: database-deployment
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: ðŸ“„ Load configuration from JSON
        shell: pwsh
        id: load_config
        run: |
          # read JSON file
          $config = Get-Content -Raw -Path "config.json" | ConvertFrom-Json

          # Check JSON file
          Write-Output "Config Loaded: $($config | ConvertTo-Json -Depth 3)"

          $RPT_SERVER = $config.RPT_SERVER
          $RPT_SERVER_USER = $config.RPT_SERVER_USER
          $RPT_SERVER_PASS = $config.RPT_SERVER_PASS
          $IODS_API = $config.IODS_API

          # Assign JSON values to environment variables
          Add-Content -Path $env:GITHUB_ENV -Value "RPT_SERVER=$RPT_SERVER"
          Add-Content -Path $env:GITHUB_ENV -Value "RPT_SERVER_USER=$RPT_SERVER_USER"
          Add-Content -Path $env:GITHUB_ENV -Value "RPT_SERVER_PASS=$RPT_SERVER_PASS"
          Add-Content -Path $env:GITHUB_ENV -Value "IODS_API=$API_IODS"

      - name: Debug - Show Loaded Variables
        shell: pwsh
        run: |
          Write-Output "RPT_SERVER: $env:RPT_SERVER"
          Write-Output "RPT_SERVER_USER: $env:RPT_SERVER_USER"
          Write-Output "RPT_SERVER_PASS: $env:RPT_SERVER_PASS"

      - name: Generate SSH Key
        shell: bash
        run: |
          if [ ! -f "private_key.pem" ]; then
            echo "Generating SSH Key..."
            ssh-keygen -t rsa -b 4096 -f private_key -N "" || exit 1
            if [ -f "private_key.pub" ]; then
              mv private_key private_key.pem
              mv private_key.pub public_key.pub
            else
              echo "Error: SSH public key not generated!"
              exit 1
            fi
          fi
          chmod 600 private_key.pem

      # - name: Enable SSH on Remote Server (via WinRM)
      #   uses: appleboy/ssh-action@v1.0.3
      #   with:
      #     host: ${{ env.RPT_SERVER }}
      #     username: ${{ env.RPT_SERVER_USER }}
      #     password: ${{ env.RPT_SERVER_PASS }}
      #     script: |
      #       Write-Host "Installing OpenSSH Server..."
      #       Get-WindowsFeature -Name OpenSSH-Server | Install-WindowsFeature
      #       Start-Service sshd
      #       Set-Service -Name sshd -StartupType Automatic
      #       New-NetFirewallRule -Protocol TCP -LocalPort 22 -Direction Inbound -Action Allow -DisplayName "SSH"

      - name: Enable SSH on Remote Server (via WinRM)
        shell: pwsh
        run: |
          $securePassword = ConvertTo-SecureString "${{ env.RPT_SERVER_PASS }}" -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential ("${{ env.RPT_SERVER_USER }}", $securePassword)

          Invoke-Command -ComputerName "${{ env.RPT_SERVER }}" -Credential $credential -ScriptBlock {
            Write-Host "Installing OpenSSH Server..."
            Install-WindowsFeature -Name OpenSSH-Server
            Start-Service sshd
            Set-Service -Name sshd -StartupType Automatic
            New-NetFirewallRule -Protocol TCP -LocalPort 22 -Direction Inbound -Action Allow -DisplayName "SSH"
          }

      - name: Add SSH Key to Remote Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.RPT_SERVER }}
          username: ${{ env.RPT_SERVER_USER }}
          password: ${{ env.RPT_SERVER_PASS }}
          script: |
            mkdir -Force C:\Users\${{ env.RPT_SERVER_USER }}\.ssh
            echo "${{ env.SSH_PUBLIC_KEY }}" >> C:\Users\${{ env.RPT_SERVER_USER }}\.ssh\authorized_keys
            icacls C:\Users\${{ env.RPT_SERVER_USER }}\.ssh\authorized_keys /inheritance:r
            icacls C:\Users\${{ env.RPT_SERVER_USER }}\.ssh\authorized_keys /grant "${{ env.RPT_SERVER_USER }}:F"

      # - name: Setup SSH Key
      #   run: |
      #     echo "${{ secrets.SSH_KEY }}" > private_key.pem
      #     chmod 600 private_key.pem

      - name: Copy files using SCP
        run: |
          scp -i private_key.pem -o StrictHostKeyChecking=no -r API-iODS.zip AppPoolCreation.ps1 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:"C:/Users/Public/Desktop/"

      # - name: Extract API-iODS.zip
      #   run: |
      #     echo "Desplegando API en IIS..."
      #     Expand-Archive -Path "$env:IODS_API/API-iODS.zip" -DestinationPath "C:\inetpub\wwwroot\API-iODS"

      # - name: Debug - List extracted files
      #   run: |
      #     Get-ChildItem -Path "C:\inetpub\wwwroot\API-iODS" -Recurse
      #   shell: pwsh

      # - name: Configure IIS Site
      #   run: |
      #     Import-Module WebAdministration
      #     New-WebApplication -Site "Default Web Site" -Name "API-iODS" -PhysicalPath "C:\inetpub\wwwroot\API-iODS" -ApplicationPool "NET v4.5 iODS"

      # - name: Update Web.config
      #   run: |
      #     $configPath = "C:\inetpub\wwwroot\API-iODS\Web.config"
      #     (Get-Content $configPath) -replace 'data source=.*?;', 'data source=CNSG-MESDTA2BR.int.pg.com;' | Set-Content $configPath

      # - name: Update WhiteList.json
      #   run: |
      #     $whitelistPath = "C:\inetpub\wwwroot\API-iODS\WhiteList.json"
      #     (Invoke-WebRequest -Uri "https://github.com/DMO/IODS/blob/b7c13f3fd96f9b8981240ce054099c5b553b84a1/Documentation/Install%20Documentation/whitelist.json" -UseBasicParsing).Content | Set-Content $whitelistPath

      # - name: Run AppPoolCreation.ps1
      #   run: |
      #     Start-Process -FilePath "powershell.exe" -ArgumentList "-ExecutionPolicy Bypass -File AppPoolCreation.ps1" -NoNewWindow -Wait

      # - name: Configure IIS Authentication
      #   run: |
      #     Import-Module WebAdministration
      #     Set-WebConfigurationProperty -Filter "/system.webServer/security/authentication/anonymousAuthentication" -Name "userName" -Value ""

      # - name: Configure IIS Application Pool
      #   run: |
      #     Set-ItemProperty "IIS:\AppPools\NET v4.5 iODS" -Name processModel.identityType -Value ApplicationPoolIdentity

      # - name: Restart IIS
      #   run: |
      #     iisreset
